clc; 
clear;

% 1. Define the function using an anonymous handle
f = @(a) cosh(100./a) - 11;

% 2. Define interval and tolerance
a_init = 20;
b_init = 50;
tolerance = 1e-4;

fprintf('Bisection Method Calculation:\n');
fprintf('Solving f(a) = cosh(100/a) - 11 = 0\n');
fprintf('Interval: [%d, %d], Tolerance: %.1e\n\n', a_init, b_init, tolerance);

% 3. Call the bisection function
[root, error, iterations] = bisection(f, a_init, b_init, tolerance);

% 4. Print the final solution
fprintf('\n--------------------------------------------------\n');
fprintf('Final Solution found after %d iterations:\n', iterations);
fprintf('Root (xst)       = %.8f\n', root);
fprintf('Final Error (erra) = %.8f\n', error);
fprintf('--------------------------------------------------\n');


function [xst, erra, iter] = bisection(func, a, b, tol)
    % BISECTION Finds the root of a function within interval [a, b]
    % Inputs:
    %   func - function handle to solve
    %   a, b - interval limits
    %   tol  - error tolerance
    
    % Check if interval is valid (sign change check)
    if func(a) * func(b) >= 0
        error('The function must have opposite signs at the interval endpoints [a, b].');
    end

    xst = a;        % Initialize current root guess
    erra = 1.0;     % Initialize error (greater than tol to start loop)
    iter = 0;       % Iteration counter

    fprintf('Iteration Log (First 3 Only):\n');
    fprintf('Iter |      a      |      b      |     xst     |    erra\n');
    fprintf('-----|-------------|-------------|-------------|-------------\n');

    while erra > tol
        xold = xst;          % Store previous guess
        xst = (a + b) / 2;   % Calculate midpoint
        iter = iter + 1;
        
        % Calculate Approximate Relative Error (skip for very first guess)
        if xst ~= 0
            erra = abs((xst - xold) / xst);
        end
        
        % PRINT constraint: Print result of the first 3 iterations
        if iter <= 3
            fprintf('  %d  |  %9.5f  |  %9.5f  |  %9.5f  |  %.5e\n', ...
                    iter, a, b, xst, erra);
        end
        
        % Determine which sub-interval to keep
        test = func(a) * func(xst);
        
        if test < 0
            b = xst; % Root is in the left half
        elseif test > 0
            a = xst; % Root is in the right half
        else
            erra = 0; % Exact match found
        end
    end
end